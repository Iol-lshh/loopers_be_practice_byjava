# MySQL 쿼리 실행계획 분석 리포트 (EXPLAIN ANALYZE)

**생성 시간**: Fri Aug 15 04:51:57 KST 2025
**데이터베이스**: loopers
**호스트**: localhost:3306
**사용자**: application


## 연결 정보

✅ **연결 상태**: 성공
**연결 방식**: Docker

## 쿼리 분석: product_order_by_likecount_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
WITH
    hot AS (
        SELECT ls.target_id, ls.like_count
        FROM like_summary ls FORCE INDEX (idx_ls_type_like_tid)
                 JOIN product p FORCE INDEX (idx_product_state_brand_id)
                      ON p.id = ls.target_id
        WHERE ls.target_type = 'PRODUCT'
          AND p.state = 'OPEN'
        ORDER BY ls.like_count DESC, ls.target_id
        LIMIT 100
    ),
    cold AS (
        SELECT p.id
        FROM product p FORCE INDEX (idx_product_state_brand_id)
                 LEFT JOIN like_summary ls
                           ON ls.target_id = p.id AND ls.target_type = 'PRODUCT'
        WHERE p.state = 'OPEN'
          AND ls.target_id IS NULL
        ORDER BY p.id
        LIMIT 100
    )
SELECT
    u.b, u.id, p.brand_id, p.created_at, p.deleted_at, p.name, p.price, p.released_at, p.state, p.stock, p.updated_at, u.like_count
    FROM (SELECT 0 b, h.target_id id, h.like_count FROM hot h
    UNION ALL
    SELECT 1 b, c.id, NULL FROM cold c) u
    JOIN product p ON p.id = u.id
ORDER BY u.b, u.like_count DESC, p.id
    LIMIT 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=277..277 rows=20 loops=1)
    -> Sort: u.b, u.like_count DESC, p.id, limit input to 20 row(s) per chunk  (actual time=277..277 rows=20 loops=1)
        -> Stream results  (cost=596997 rows=100) (actual time=276..277 rows=100 loops=1)
            -> Nested loop inner join  (cost=596997 rows=100) (actual time=276..277 rows=100 loops=1)
                -> Table scan on u  (cost=596935..596939 rows=100) (actual time=276..276 rows=100 loops=1)
                    -> Union all materialize  (cost=596935..596935 rows=100) (actual time=276..276 rows=100 loops=1)
                        -> Table scan on h  (cost=47143..47143 rows=0.5) (actual time=0.0179..0.0179 rows=0 loops=1)
                            -> Materialize CTE hot  (cost=47141..47141 rows=0.5) (actual time=0.0164..0.0164 rows=0 loops=1)
                                -> Limit: 100 row(s)  (cost=47141 rows=0.5) (actual time=0.015..0.015 rows=0 loops=1)
                                    -> Nested loop inner join  (cost=47141 rows=0.5) (actual time=0.0148..0.0148 rows=0 loops=1)
                                        -> Filter: (ls.target_type = 'PRODUCT')  (cost=0.35 rows=1) (actual time=0.0137..0.0137 rows=0 loops=1)
                                            -> Covering index lookup on ls using idx_ls_type_like_tid (target_type='PRODUCT')  (cost=0.35 rows=1) (actual time=0.0109..0.0109 rows=0 loops=1)
                                        -> Filter: ((p.id = ls.target_id) and (p.state = 'OPEN'))  (cost=1447 rows=0.5) (never executed)
                                            -> Covering index lookup on p using idx_product_state_brand_id (state='OPEN')  (cost=1447 rows=456934) (never executed)
                        -> Table scan on c  (cost=549778..549782 rows=100) (actual time=276..276 rows=100 loops=1)
                            -> Materialize CTE cold  (cost=549778..549778 rows=100) (actual time=276..276 rows=100 loops=1)
                                -> Limit: 100 row(s)  (cost=549768 rows=100) (actual time=276..276 rows=100 loops=1)
                                    -> Filter: (ls.target_id is null)  (cost=549768 rows=456934) (actual time=276..276 rows=100 loops=1)
                                        -> Nested loop antijoin  (cost=549768 rows=456934) (actual time=276..276 rows=100 loops=1)
                                            -> Sort: p.id  (cost=47140 rows=456934) (actual time=276..276 rows=100 loops=1)
                                                -> Filter: (p.state = 'OPEN')  (cost=47140 rows=456934) (actual time=0.0249..149 rows=721559 loops=1)
                                                    -> Index lookup on p using idx_product_state_brand_id (state='OPEN')  (cost=47140 rows=456934) (actual time=0.0237..95.3 rows=721559 loops=1)
                                            -> Filter: (ls.target_type = 'PRODUCT')  (cost=1 rows=1) (actual time=0.00213..0.00213 rows=0 loops=100)
                                                -> Single-row covering index lookup on ls using PRIMARY (target_id=p.id, target_type='PRODUCT')  (cost=1 rows=1) (actual time=0.00204..0.00204 rows=0 loops=100)
                -> Single-row index lookup on p using PRIMARY (id=u.id)  (cost=0.47 rows=1) (actual time=0.00181..0.00183 rows=1 loops=100)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 277..277ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_likecount_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by lse1_0.like_count desc,pe1_0.id
limit 20 offset 0;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=37..37 rows=20 loops=1)
    -> Sort: lse1_0.like_count DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=37..37 rows=20 loops=1)
        -> Stream results  (cost=12568 rows=13674) (actual time=0.483..36 rows=7598 loops=1)
            -> Nested loop left join  (cost=12568 rows=13674) (actual time=0.473..32.9 rows=7598 loops=1)
                -> Index lookup on pe1_0 using idx_product_state_brand_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=7782 rows=13674) (actual time=0.466..28.2 rows=7598 loops=1)
                -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=529e-6..529e-6 rows=0 loops=7598)
                    -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=445e-6..445e-6 rows=0 loops=7598)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 37..37ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=212124 rows=0) (actual time=0.405..0.405 rows=0 loops=1)
    -> Nested loop left join  (cost=212124 rows=456934) (actual time=0.387..0.403 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_price_id (state='OPEN'), with index condition: (pe1_0.state = 'OPEN')  (cost=52197 rows=456934) (actual time=0.368..0.372 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=0.00131..0.00131 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=0.00119..0.00119 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.405..0.405ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=10759 rows=0) (actual time=0.302..0.302 rows=0 loops=1)
    -> Nested loop left join  (cost=10759 rows=13674) (actual time=0.286..0.301 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_brand_price_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=5973 rows=13674) (actual time=0.28..0.283 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=715e-6..715e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=617e-6..617e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.302..0.302ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,
    pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.released_at desc,pe1_0.id
limit 0 offset 20;


```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=212129 rows=0) (actual time=0.624..0.624 rows=0 loops=1)
    -> Nested loop left join  (cost=212129 rows=456934) (actual time=0.609..0.623 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_rel_id (state='OPEN'), with index condition: (pe1_0.state = 'OPEN')  (cost=52202 rows=456934) (actual time=0.602..0.605 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=754e-6..754e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=619e-6..619e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.624..0.624ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state='OPEN'
order by pe1_0.released_at desc, pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=10759 rows=0) (actual time=0.338..0.338 rows=0 loops=1)
    -> Nested loop left join  (cost=10759 rows=13674) (actual time=0.322..0.337 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_brand_rel_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=5973 rows=13674) (actual time=0.317..0.319 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=719e-6..719e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=610e-6..610e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.338..0.338ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---


## 요약

**총 분석된 쿼리 수**: 6
**연결 방식**: Docker
**분석 방식**: EXPLAIN ANALYZE (실제 실행 시간 포함)
**생성된 파일들**: 
- 📊 마크다운 리포트: query_analysis_20250815_045156.md
- 🔍 개별 실행계획 텍스트: queries 디렉토리 참조
