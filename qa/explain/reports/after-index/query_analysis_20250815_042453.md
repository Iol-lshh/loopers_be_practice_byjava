# MySQL 쿼리 실행계획 분석 리포트 (EXPLAIN ANALYZE)

**생성 시간**: Fri Aug 15 04:24:53 KST 2025
**데이터베이스**: loopers
**호스트**: localhost:3306
**사용자**: application


## 연결 정보

✅ **연결 상태**: 성공
**연결 방식**: Docker

## 쿼리 분석: product_order_by_likecount_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by lse1_0.like_count desc,pe1_0.id
limit 20 offset 0;

```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=3561..3561 rows=20 loops=1)
    -> Sort: lse1_0.like_count DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=3561..3561 rows=20 loops=1)
        -> Stream results  (cost=212188 rows=455977) (actual time=0.933..3462 rows=721838 loops=1)
            -> Nested loop left join  (cost=212188 rows=455977) (actual time=0.916..3184 rows=721838 loops=1)
                -> Index lookup on pe1_0 using idx_product_state_price_id (state='OPEN'), with index condition: (pe1_0.state = 'OPEN')  (cost=52596 rows=455977) (actual time=0.901..2735 rows=721838 loops=1)
                -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=522e-6..522e-6 rows=0 loops=721838)
                    -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=437e-6..437e-6 rows=0 loops=721838)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 3561..3561ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_likecount_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by lse1_0.like_count desc,pe1_0.id
limit 20 offset 0;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=72.9..72.9 rows=20 loops=1)
    -> Sort: lse1_0.like_count DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=72.9..72.9 rows=20 loops=1)
        -> Stream results  (cost=10969 rows=13592) (actual time=3.4..71.7 rows=7553 loops=1)
            -> Nested loop left join  (cost=10969 rows=13592) (actual time=3.39..68.7 rows=7553 loops=1)
                -> Index lookup on pe1_0 using idx_product_state_brand_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=6212 rows=13592) (actual time=3.38..63.8 rows=7553 loops=1)
                -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=552e-6..552e-6 rows=0 loops=7553)
                    -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=463e-6..463e-6 rows=0 loops=7553)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 72.9..72.9ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=211875 rows=0) (actual time=0.969..0.969 rows=0 loops=1)
    -> Nested loop left join  (cost=211875 rows=455977) (actual time=0.952..0.967 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_price_id (state='OPEN'), with index condition: (pe1_0.state = 'OPEN')  (cost=52283 rows=455977) (actual time=0.943..0.946 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=871e-6..871e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=756e-6..756e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.969..0.969ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=10819 rows=0) (actual time=0.425..0.425 rows=0 loops=1)
    -> Nested loop left join  (cost=10819 rows=13592) (actual time=0.409..0.424 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_brand_price_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=6062 rows=13592) (actual time=0.402..0.404 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=767e-6..767e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=664e-6..664e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.425..0.425ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,
    pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.released_at desc,pe1_0.id
limit 0 offset 20;


```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=211875 rows=0) (actual time=0.366..0.366 rows=0 loops=1)
    -> Nested loop left join  (cost=211875 rows=455977) (actual time=0.35..0.365 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_rel_id (state='OPEN'), with index condition: (pe1_0.state = 'OPEN')  (cost=52283 rows=455977) (actual time=0.343..0.345 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=781e-6..781e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=677e-6..677e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.366..0.366ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state='OPEN'
order by pe1_0.released_at desc, pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (cost=10819 rows=0) (actual time=0.492..0.492 rows=0 loops=1)
    -> Nested loop left join  (cost=10819 rows=13592) (actual time=0.476..0.491 rows=20 loops=1)
        -> Index lookup on pe1_0 using idx_product_state_brand_rel_id (state='OPEN', brand_id=1), with index condition: (pe1_0.state = 'OPEN')  (cost=6062 rows=13592) (actual time=0.466..0.468 rows=20 loops=1)
        -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.25 rows=1) (actual time=913e-6..913e-6 rows=0 loops=20)
            -> Single-row index lookup on lse1_0 using PRIMARY (target_id=pe1_0.id, target_type='PRODUCT')  (cost=0.25 rows=1) (actual time=809e-6..809e-6 rows=0 loops=20)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 0.492..0.492ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---


## 요약

**총 분석된 쿼리 수**: 6
**연결 방식**: Docker
**분석 방식**: EXPLAIN ANALYZE (실제 실행 시간 포함)
**생성된 파일들**: 
- 📊 마크다운 리포트: query_analysis_20250815_042453.md
- 🔍 개별 실행계획 텍스트: queries 디렉토리 참조
