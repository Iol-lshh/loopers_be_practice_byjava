# MySQL 쿼리 실행계획 분석 리포트 (EXPLAIN ANALYZE)

**생성 시간**: Fri Aug 15 04:04:00 KST 2025
**데이터베이스**: loopers
**호스트**: localhost:3306
**사용자**: application


## 연결 정보

✅ **연결 상태**: 성공
**연결 방식**: Docker

## 쿼리 분석: product_order_by_likecount_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by lse1_0.like_count desc,pe1_0.id
limit 20 offset 0;

```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=714..714 rows=20 loops=1)
    -> Sort: lse1_0.like_count DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=714..714 rows=20 loops=1)
        -> Stream results  (cost=31697 rows=304333) (actual time=0.26..621 rows=721838 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=31697 rows=304333) (actual time=0.227..348 rows=721838 loops=1)
                -> Filter: (pe1_0.state = 'OPEN')  (cost=91300 rows=304333) (actual time=0.0615..287 rows=721838 loops=1)
                    -> Table scan on pe1_0  (cost=91300 rows=913000) (actual time=0.058..219 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00415 rows=1) (actual time=0.148..0.148 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00415 rows=1) (actual time=0.147..0.147 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 714..714ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_likecount_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by lse1_0.like_count desc,pe1_0.id
limit 20 offset 0;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit: 20 row(s)  (actual time=283..283 rows=20 loops=1)
    -> Sort: lse1_0.like_count DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=283..283 rows=20 loops=1)
        -> Stream results  (cost=3075 rows=30433) (actual time=0.0923..282 rows=7553 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=3075 rows=30433) (actual time=0.0843..278 rows=7553 loops=1)
                -> Filter: ((pe1_0.state = 'OPEN') and (pe1_0.brand_id = 1))  (cost=91300 rows=30433) (actual time=0.0601..277 rows=7553 loops=1)
                    -> Table scan on pe1_0  (cost=91300 rows=913000) (actual time=0.0427..210 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00105 rows=1) (actual time=0.0192..0.0192 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00105 rows=1) (actual time=0.0184..0.0184 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 283..283ms
📊 스캔된 행 수: 20

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (actual time=699..699 rows=0 loops=1)
    -> Sort: pe1_0.price, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=699..699 rows=20 loops=1)
        -> Stream results  (cost=30749 rows=304333) (actual time=0.0697..612 rows=721838 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=30749 rows=304333) (actual time=0.0637..341 rows=721838 loops=1)
                -> Filter: (pe1_0.state = 'OPEN')  (cost=91300 rows=304333) (actual time=0.044..282 rows=721838 loops=1)
                    -> Table scan on pe1_0  (cost=91300 rows=913000) (actual time=0.043..213 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00104 rows=1) (actual time=0.0153..0.0153 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00104 rows=1) (actual time=0.0145..0.0145 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 699..699ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_price_asc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state = 'OPEN'
order by pe1_0.price,pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (actual time=275..275 rows=0 loops=1)
    -> Sort: pe1_0.price, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=275..275 rows=20 loops=1)
        -> Stream results  (cost=3075 rows=30433) (actual time=0.0862..274 rows=7553 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=3075 rows=30433) (actual time=0.0793..271 rows=7553 loops=1)
                -> Filter: ((pe1_0.state = 'OPEN') and (pe1_0.brand_id = 1))  (cost=91300 rows=30433) (actual time=0.0552..270 rows=7553 loops=1)
                    -> Table scan on pe1_0  (cost=91300 rows=913000) (actual time=0.0418..207 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00105 rows=1) (actual time=0.0165..0.0165 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00105 rows=1) (actual time=0.0157..0.0157 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 275..275ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,
    pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.state = 'OPEN'
order by pe1_0.released_at desc,pe1_0.id
limit 0 offset 20;


```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (actual time=725..725 rows=0 loops=1)
    -> Sort: pe1_0.released_at DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=725..725 rows=20 loops=1)
        -> Stream results  (cost=30749 rows=304333) (actual time=0.0726..630 rows=721838 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=30749 rows=304333) (actual time=0.0657..356 rows=721838 loops=1)
                -> Filter: (pe1_0.state = 'OPEN')  (cost=91300 rows=304333) (actual time=0.0438..294 rows=721838 loops=1)
                    -> Table scan on pe1_0  (cost=91300 rows=913000) (actual time=0.0428..226 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00104 rows=1) (actual time=0.0171..0.0171 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00104 rows=1) (actual time=0.0165..0.0165 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 725..725ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---

## 쿼리 분석: product_order_by_released_at_desc_with_brand_filter.sql

🔍 쿼리 내용:
```sql
-- MySQL 실행계획 확인
EXPLAIN ANALYZE
select
    pe1_0.id,pe1_0.brand_id,pe1_0.created_at,pe1_0.deleted_at,pe1_0.name,pe1_0.price,pe1_0.released_at,pe1_0.state,pe1_0.stock,pe1_0.updated_at,lse1_0.like_count
from product pe1_0
left join like_summary lse1_0 on pe1_0.id=lse1_0.target_id and lse1_0.target_type='PRODUCT'
where pe1_0.brand_id=1
and pe1_0.state='OPEN'
order by pe1_0.released_at desc, pe1_0.id
limit 0 offset 20;
```

📊 실행계획 분석 (EXPLAIN ANALYZE):
### 실행계획 결과

```
EXPLAIN
-> Limit/Offset: 0/20 row(s)  (actual time=275..275 rows=0 loops=1)
    -> Sort: pe1_0.released_at DESC, pe1_0.id, limit input to 20 row(s) per chunk  (actual time=275..275 rows=20 loops=1)
        -> Stream results  (cost=3072 rows=30398) (actual time=0.0913..274 rows=7553 loops=1)
            -> Left hash join (lse1_0.target_id = pe1_0.id)  (cost=3072 rows=30398) (actual time=0.0843..271 rows=7553 loops=1)
                -> Filter: ((pe1_0.state = 'OPEN') and (pe1_0.brand_id = 1))  (cost=92806 rows=30398) (actual time=0.0622..270 rows=7553 loops=1)
                    -> Table scan on pe1_0  (cost=92806 rows=911954) (actual time=0.0464..206 rows=913000 loops=1)
                -> Hash
                    -> Filter: (lse1_0.target_type = 'PRODUCT')  (cost=0.00105 rows=1) (actual time=0.0171..0.0171 rows=0 loops=1)
                        -> Table scan on lse1_0  (cost=0.00105 rows=1) (actual time=0.0164..0.0164 rows=0 loops=1)
```

📋 실행계획 요약:
⏱️  실제 실행 시간: 275..275ms
📊 스캔된 행 수: 0

⚠️  주요 성능 이슈:

---


## 요약

**총 분석된 쿼리 수**: 6
**연결 방식**: Docker
**분석 방식**: EXPLAIN ANALYZE (실제 실행 시간 포함)
**생성된 파일들**: 
- 📊 마크다운 리포트: query_analysis_20250815_040400.md
- 🔍 개별 실행계획 텍스트: queries 디렉토리 참조
